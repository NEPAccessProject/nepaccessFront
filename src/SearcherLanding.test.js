// Generated by CodiumAI

describe('SearcherLanding', () => {

    // User inputs search query and clicks search icon
    it('should update state and call onClick function when search icon is clicked', () => {
      const mockOnChange = jest.fn();
      const mockOnClick = jest.fn();
      const wrapper = shallow(<SearcherLanding onChange={mockOnChange} onClick={mockOnClick} />);
      const input = wrapper.find('#main-search-text-field');
      const iconButton = wrapper.find(IconButton);

      // Simulate user input
      input.simulate('change', { target: { name: 'titleRaw', value: 'test query' } });

      // Simulate click on search icon
      iconButton.simulate('click');

      // Check if state is updated correctly
      expect(wrapper.state('titleRaw')).toEqual('test query');

      // Check if onChange function is called with correct arguments
      expect(mockOnChange).toHaveBeenCalledWith(wrapper.props().id, 'test query');

      // Check if onClick function is called with correct arguments
      expect(mockOnClick).toHaveBeenCalledWith('render', 'app');
    });


    // Globals.setUp() sets currentHost and default axios headers
    it('should set currentHost and default axios headers when calling Globals.setUp()', () => {
      const searcherLanding = new SearcherLanding();
      const currentHost = new URL('http://localhost:8080/');
  
      searcherLanding.setUp();
  
      expect(Globals.currentHost).toEqual(currentHost);
      expect(axios.defaults.headers.common['Content-Type']).toEqual('application/json;charset=utf-8');
      expect(axios.defaults.headers.common['X-Content-Type-Options']).toEqual('no-sniff');
      expect(axios.defaults.headers.common['Access-Control-Allow-Origin']).toEqual('*');
    });


    // User clears search query
    it('should clear the search query when the clear button is clicked', () => {
      // Create a mock event object
      const mockEvent = {
        target: {
          name: 'titleRaw',
          value: 'example query'
        }
      };

      // Create a mock props object
      const mockProps = {
        id: 'exampleId',
        onChange: jest.fn()
      };

      // Create a mock state object
      const mockState = {
        titleRaw: 'example query'
      };

      // Create a mock SearcherLanding component
      const searcherLanding = new SearcherLanding(mockProps);

      // Set the state of the SearcherLanding component
      searcherLanding.state = mockState;

      // Call the onClearClick method
      searcherLanding.onClearClick();

      // Check if the titleRaw state is cleared
      expect(searcherLanding.state.titleRaw).toBe('');

      // Check if the onChange prop is called with the correct arguments
      expect(mockProps.onChange).toHaveBeenCalledWith(mockProps.id, '');

    });


    // User inputs search query and presses enter key
    it('should call onClick function with correct parameters when enter key is pressed', () => {
      const mockOnChange = jest.fn();
      const mockOnClick = jest.fn();
      const wrapper = shallow(<SearcherLanding onChange={mockOnChange} onClick={mockOnClick} />);
      const input = wrapper.find('#main-search-text-field');
      const event = { target: { name: 'titleRaw', value: 'test query' }, keyCode: 13 };

      input.simulate('keyUp', event);

      expect(mockOnChange).toHaveBeenCalledWith('render', 'app');
      expect(mockOnClick).toHaveBeenCalledWith('render', 'app');
    });


    // Globals.signIn() sets axios Authorization header
    it('should set axios Authorization header when signIn is called', () => {
        const searchLanding = new SearcherLanding();
        searchLanding.signIn();
        expect(axios.defaults.headers.common['Authorization']).not.toBeNull();
    });


    // Globals.signOut() clears localStorage and sets axios Authorization header to null
    it('should clear localStorage and set axios Authorization header to null when signOut is called', () => {
      // Arrange
      const localStorageMock = {
        clear: jest.fn()
      };
      global.localStorage = localStorageMock;
      axios.defaults.headers.common['Authorization'] = 'token';

      // Act
      Globals.signOut();

      // Assert
      expect(localStorageMock.clear).toHaveBeenCalled();
      expect(axios.defaults.headers.common['Authorization']).toBeNull();
    });


    // Invalid search query provided (e.g. special characters)
    it('should handle invalid search query', () => {
        const wrapper = shallow(<SearcherLanding />);
        const input = wrapper.find('#main-search-text-field');
        input.simulate('change', { target: { name: 'titleRaw', value: '@#$%' } });
        expect(wrapper.state('titleRaw')).toEqual('@#$%');
        expect(wrapper.props().value).toEqual('@#$%');
    });


    // Error response from getTitles() API call
    it('should handle error response from getTitles() API call', () => {
        const wrapper = shallow(<SearcherLanding />);
        const instance = wrapper.instance();

        const axiosMock = jest.spyOn(axios, 'post');
        axiosMock.mockRejectedValueOnce(new Error('API error'));

        instance.getTitles();

        expect(axiosMock).toHaveBeenCalledWith(
            expect.any(String),
            expect.any(Object)
        );

        expect(wrapper.state('titles')).toBeNull();
    });


    // User changes search query
    it('should update the state and call the onChange prop when the search query is changed', () => {
      // Create a mock onChange prop function
      const onChangeMock = jest.fn();
  
      // Render the SearcherLanding component with the mock onChange prop
      const wrapper = shallow(<SearcherLanding onChange={onChangeMock} />);
  
      // Simulate a change event on the search input
      wrapper.find('#main-search-text-field').simulate('change', { target: { name: 'titleRaw', value: 'new query' } });
  
      // Check if the state is updated correctly
      expect(wrapper.state('titleRaw')).toEqual('new query');
  
      // Check if the onChange prop is called with the correct arguments
      expect(onChangeMock).toHaveBeenCalledWith(wrapper.props().id, 'new query');
    });


    // No search query provided
    it('should clear the search query and call the onChange function with an empty string', () => {
      // Arrange
      const onChangeMock = jest.fn();
      const props = {
        id: 'search',
        onChange: onChangeMock,
      };
      const wrapper = shallow(<SearcherLanding {...props} />);
      const input = wrapper.find('#main-search-text-field');

      // Act
      input.simulate('change', { target: { name: 'titleRaw', value: 'test' } });
      wrapper.instance().onClearClick();

      // Assert
      expect(wrapper.state('titleRaw')).toEqual('');
      expect(onChangeMock).toHaveBeenCalledWith('search', '');
    });


    // No response from get() API call
    it('should handle no response from get() API call', () => {
        const wrapper = shallow(<SearcherLanding />);
        const instance = wrapper.instance();

        const axiosMock = jest.spyOn(axios, 'get');
        axiosMock.mockImplementation(() => Promise.reject());

        instance.get('test/url', 'stateName');

        expect(axiosMock).toHaveBeenCalledWith(expect.any(URL), {
            url: expect.any(URL),
            method: 'GET',
            data: {}
        });

        expect(wrapper.state('stateName')).toBeUndefined();

        axiosMock.mockRestore();
    });


    // Error response from get() API call
    it('should handle error response from get() API call', () => {
        const wrapper = shallow(<SearcherLanding />);
        const instance = wrapper.instance();

        const mockAxios = jest.spyOn(axios, 'get');
        mockAxios.mockRejectedValue(new Error('Error'));

        instance.get('test/url', 'stateName');

        expect(mockAxios).toHaveBeenCalledWith(expect.any(URL), {
            url: expect.any(URL),
            method: 'GET',
            data: {}
        });

        expect(wrapper.state('stateName')).toBe(null);
    });


    // get() sets state with response data if successful
    it('should set state with response data when get() is successful', () => {
      // Mock the axios library
      jest.mock('axios');
      const axios = require('axios');

      // Mock the response data
      const responseData = { title: 'Test Title' };
      axios.mockResolvedValue({ data: responseData });

      // Create an instance of SearcherLanding
      const searcherLanding = new SearcherLanding();

      // Call the get() method
      searcherLanding.get('test/url', 'title');

      // Check if the state is updated with the response data
      expect(searcherLanding.state.title).toEqual(responseData);
    });


    // onClearClick() does not modify state if input is already empty
    it('should not modify state if input is already empty', () => {
      const wrapper = shallow(<SearcherLanding />);
      const instance = wrapper.instance();
      instance.setState({ titleRaw: '' });
      instance.onClearClick();
      expect(instance.state.titleRaw).toEqual('');
    });


    // onChangeHandler() does not modify state if input is empty
    it('should not modify state when input is empty', () => {
      const wrapper = shallow(<SearcherLanding />);
      const instance = wrapper.instance();
      const event = { target: { name: 'titleRaw', value: '' } };

      instance.onChangeHandler(event);

      expect(wrapper.state('titleRaw')).toEqual('');
    });


    // getTitles() sets titles state if successful
    it('should set titles state when getTitles is successful', () => {
      const wrapper = shallow(<SearcherLanding />);
      const instance = wrapper.instance();
      const mockResponse = { data: ['title1', 'title2'] };
      axios.mockResolvedValueOnce(mockResponse);

      return instance.getTitles().then(() => {
        expect(instance.state.titles).toEqual(mockResponse.data);
      });
    });


    // onKeyUp() does not trigger search if enter key is not pressed
    it('should not trigger search when enter key is not pressed', () => {
      const wrapper = shallow(<SearcherLanding />);
      const instance = wrapper.instance();
      const mockOnClick = jest.fn();
      instance.props = {
        onChange: jest.fn(),
        onClick: mockOnClick,
        id: 'testId'
      };
      const event = {
        keyCode: 65,
        target: {
          name: 'titleRaw',
          value: 'test value'
        }
      };
      instance.onKeyUp(event);
      expect(mockOnClick).not.toHaveBeenCalled();
    });


});
